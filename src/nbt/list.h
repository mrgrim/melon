//
// Created by MrGrim on 8/19/2022.
//

#ifndef MELON_NBT_LIST_H
#define MELON_NBT_LIST_H

#include <cstdint>
#include <iterator>
#include <memory>
#include <string>
#include <vector>
#include <memory>
#include <memory_resource>
#include <cassert>
#include <functional>
#include "nbt.h"
#include "util/concepts.h"

namespace melon::nbt
{
    class compound;

    class list
    {
    public:
        using allocator_type = std::pmr::polymorphic_allocator<std::byte>;
        using tag_list_t = std::pmr::vector<void *>;

        // @formatter:off
        template<tag_type_enum tag_type>
        requires (tag_type != tag_end)
        class iterator
        {
            friend class list;

            tag_list_t::iterator itr;

            tag_access_t<tag_type> &fetch_non_array_value(void *ptr) const
            {
                if constexpr (tag_properties[tag_type].category & (cat_compound | cat_list))
                    return *static_cast<tag_cont_t<tag_type> *>(ptr);
                else
                    return static_cast<tag_cont_t<tag_type> *>(ptr)->template get<tag_type>();
            }

        public:
            using value_type = tag_access_t<tag_type>;
            using difference_type = int;
            using iterator_category = std::random_access_iterator_tag;

            iterator() : itr() { };

            explicit iterator(tag_list_t::iterator &&itr_in) : itr(std::move(itr_in)) { };

            tag_access_t<tag_type> &operator*() const requires is_nbt_primitive<tag_type> || is_nbt_container<tag_type>
            { return fetch_non_array_value(*itr); }
            tag_access_t<tag_type> &operator[](int idx) const requires is_nbt_primitive<tag_type> || is_nbt_container<tag_type>
            { return fetch_non_array_value(itr[idx]); }

            // Hopefully force return elision of the string_view or span generated by the primitive get() for array types
            tag_access_t<tag_type> operator*() const requires is_nbt_array<tag_type>
            { return static_cast<tag_cont_t<tag_type> *>(*itr)->template get<tag_type>(); }
            tag_access_t<tag_type> operator[](int idx) const requires is_nbt_array<tag_type>
            { return static_cast<tag_cont_t<tag_type> *>(itr[idx])->template get<tag_type>(); }

            auto &operator++() { itr++; return *this; };
            auto operator++(int)& { auto old = *this; ++(*this); return old; };
            auto &operator--() { itr--; return *this; };
            auto operator--(int)& { auto old = *this; --(*this); return old; };
            auto &operator+=(int diff) { itr += diff; return *this; };
            auto &operator-=(int diff) { itr -= diff; return *this; };

            friend std::strong_ordering operator<=>(const iterator<tag_type> &lhs, const iterator<tag_type> &rhs) { return lhs.itr <=> rhs.itr; }
            friend bool operator==(const iterator<tag_type> &lhs, const iterator<tag_type> &rhs) { return (lhs.itr == rhs.itr); }

            friend int operator-(iterator<tag_type> lhs, iterator<tag_type> rhs) { return rhs.itr - lhs.itr; };
            friend iterator<tag_type> operator+(iterator<tag_type> itr_in, int diff) { return iterator<tag_type>(itr_in + diff); };
            friend iterator<tag_type> operator-(iterator<tag_type> itr_in, int diff) { return iterator<tag_type>(itr_in - diff); };
            friend iterator<tag_type> operator+(int diff, iterator<tag_type> itr_in) { return itr_in + diff; };
        };
        //@formatter:on

    private:

        std::variant<compound *, list *> parent;
        compound                         *top;
        std::pmr::memory_resource        *pmr_rsrc = std::pmr::get_default_resource();

    public:
        mem::pmr::unique_ptr<std::pmr::string> name;
        const tag_type_enum                    type  = tag_end;
        int32_t                                count = 0;

        list() = delete;

        list(const list &) = delete;
        list &operator=(const list &) = delete;

        list(list &&) = delete;
        list &operator=(list &&) = delete;

        void to_snbt(std::string &out);

        // @formatter:off
        template<tag_type_enum tag_type> requires (tag_type != tag_end)
        iterator<tag_type> begin()
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempt to create iterator of invalid NBT list type.");
            return iterator<tag_type>(tags.begin());
        }

        template<tag_type_enum tag_type> requires (tag_type != tag_end)
        iterator<tag_type> end()
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempt to create iterator of invalid NBT list type.");
            return iterator<tag_type>(tags.end());
        }

        template<tag_type_enum tag_type>
        requires is_nbt_container<tag_type>
        auto &at(int idx)
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempted access of invalid NBT list type element.");
            auto cont_ptr = static_cast<tag_cont_t<tag_type> *>(tags.at(idx));
            return *cont_ptr;
        }

        template<tag_type_enum tag_type>
        requires is_nbt_primitive<tag_type>
        auto &at(int idx)
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempted access of invalid NBT list type element.");
            return static_cast<tag_cont_t<tag_type> *>(tags.at(idx))->template get<tag_type>();
        }

        template<tag_type_enum tag_type>
        requires is_nbt_array<tag_type>
        auto at(int idx)
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempted access of invalid NBT list type element.");
            return static_cast<tag_cont_t<tag_type> *>(tags.at(idx))->template get<tag_type>();
        }
        // @formatter:on

        // It's in compound.cpp :sob:
        template<tag_type_enum tag_type>
        requires (tag_type == tag_compound)
        std::optional<std::reference_wrapper<compound>> push(const std::function<void(compound &)> &builder = nullptr);

        template<tag_type_enum tag_type>
        requires (tag_type == tag_list)
        std::optional<std::reference_wrapper<list>> push(tag_type_enum tag_type_in, const std::function<void(list &)> &builder = nullptr)
        {
            auto container = mem::pmr::make_unique<list>(pmr_rsrc, this, "", tag_type_in);
            if (tag_type_in == tag_end) throw std::runtime_error("Attempted to create NBT list with no type.");

            if (builder) builder(*container);
            auto cont_ptr = container.get();

            try
            {
                tags.push_back(static_cast<void *>(container.get()));
            } catch (...)
            {
                adjust_size(container->size() * -1);
                throw;
            }

            count++;
            static_cast<void>(container.release());
            return *cont_ptr;
        }

        template<tag_type_enum tag_type, class V = tag_prim_t<tag_type>>
        requires is_nbt_primitive<tag_type> && is_nbt_type_match<V, tag_type>
        void push(V value)
        {
            auto tag_ptr = mem::pmr::make_unique<primitive_tag>(pmr_rsrc, type);
            adjust_size(tag_ptr->size({ .full_tag = false }));

            if constexpr (tag_type == tag_byte)
                tag_ptr->value.tag_byte = value;
            else if constexpr (tag_type == tag_short)
                tag_ptr->value.tag_short = value;
            else if constexpr (tag_type == tag_int)
                tag_ptr->value.tag_int = value;
            else if constexpr (tag_type == tag_long)
                tag_ptr->value.tag_long = value;
            else if constexpr (tag_type == tag_float)
                tag_ptr->value.tag_float = value;
            else if constexpr (tag_type == tag_double)
                tag_ptr->value.tag_double = value;

            tags.push_back(static_cast<tag_cont_t<tag_type> *>(tag_ptr.get()));
            static_cast<void>(tag_ptr.release());
            count++;
        }

        template<tag_type_enum tag_type>
        requires (tag_type == tag_string)
        void push(const std::string_view &str_in)
        {
            if (tag_type != this->type) throw std::runtime_error("Attempt to push value of wrong type to NBT list.");
            push_array_general<char>(str_in);
            count++;
        }

        template<tag_type_enum tag_type, class V = std::remove_pointer_t<tag_prim_t<tag_type>>, std::size_t N>
        requires is_nbt_array<tag_type> && is_nbt_type_match<std::add_pointer_t<V>, tag_type>
        void push(const std::array<V, N> &values)
        {
            if (tag_type != this->type) throw std::runtime_error("Attempt to push value of wrong type to NBT list.");
            push_array_general<V>(values);
            count++;
        }

        template<tag_type_enum tag_type, template<class, class...> class C = std::initializer_list, class V = std::remove_pointer_t<tag_prim_t<tag_type>>, class... N>
        requires is_nbt_array<tag_type> && is_nbt_type_match<std::add_pointer_t<V>, tag_type> && util::is_simple_iterable<C<V, N...>, V>
        void push(const C<V, N...> &values)
        {
            if (tag_type != this->type) throw std::runtime_error("Attempt to push value of wrong type to NBT list.");
            push_array_general<V>(values);
            count++;
        }

        void reserve(size_t count_in)
        { tags.reserve(count_in); }

        [[nodiscard]] size_t size() const
        { return size_v; }

        void clear();

        template<tag_type_enum tag_type>
        struct range
        {
            list &list_ptr;

            auto begin()
            { return list_ptr.begin<tag_type>(); }

            auto end()
            { return list_ptr.end<tag_type>(); }
        };

        ~list();
    private:
        friend class compound;

        template<class T, class... Args>
        friend auto mem::pmr::make_obj_using_pmr(std::pmr::memory_resource *pmr_rsrc, Args &&... args)
        requires (!std::is_array_v<T>);

        explicit list(std::variant<compound *, list *> parent_in, std::string_view name_in, tag_type_enum tag_type_in);
        explicit list(char **itr_in, const char *itr_end, std::variant<compound *, list *>, mem::pmr::unique_ptr<std::pmr::string> name_in, tag_type_enum tag_type_in);

        char *read(char *itr, const char *itr_end);
        void adjust_size(int64_t by);
        void clean_primitives() noexcept;

        template<typename V>
        void push_array_general(const auto &values)
        {
            auto array_ptr = mem::pmr::make_unique<V[]>(pmr_rsrc, values.size() + (padding_size / sizeof(V)));
            auto tag_ptr   = mem::pmr::make_unique<primitive_tag>(pmr_rsrc, type);

            tag_ptr->change_count(values.size());
            adjust_size(tag_ptr->size({ .full_tag = false }));

            for (std::size_t idx = 0; const auto &value: values)
                array_ptr[idx++] = value;

            tag_ptr->value.generic_ptr = static_cast<void *>(array_ptr.get());
            tags.push_back(static_cast<void *>(tag_ptr.get()));
            static_cast<void>(array_ptr.release());
            static_cast<void>(tag_ptr.release());
        }

        tag_list_t tags;

        uint16_t depth    = 0;
        size_t   size_v   = 0;
        int64_t  max_size = -1;
    };

    static_assert(std::random_access_iterator<list::iterator<tag_compound>>);
    static_assert(std::random_access_iterator<list::iterator<tag_list>>);
    static_assert(std::random_access_iterator<list::iterator<tag_int>>);
    static_assert(std::random_access_iterator<list::iterator<tag_string>>);
    static_assert(std::random_access_iterator<list::iterator<tag_int_array>>);
}

#endif //MELON_NBT_LIST_H
