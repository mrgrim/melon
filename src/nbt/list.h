//
// Created by MrGrim on 8/19/2022.
//

#ifndef MELON_NBT_LIST_H
#define MELON_NBT_LIST_H

#include <cstdint>
#include <iterator>
#include <memory>
#include <string>
#include <vector>
#include <memory>
#include <memory_resource>
#include <cassert>
#include <functional>
#include "nbt.h"
#include "util/concepts.h"

namespace melon::nbt
{
    class compound;

    class list
    {
    public:
        using allocator_type = std::pmr::polymorphic_allocator<std::byte>;
        using tag_list_t = std::pmr::vector<std::variant<mem::pmr::unique_ptr<compound>, mem::pmr::unique_ptr<list>, mem::pmr::unique_ptr<primitive_tag>>>;

        // @formatter:off
        template<tag_type_enum tag_type>
        requires (tag_type != tag_end)
        class iterator
        {
            friend class list;

            tag_list_t *ptr;
            int     size;
            int     index;
        public:
            using value_type = tag_iter_t<tag_type>;
            using difference_type = int;
            using iterator_category = std::random_access_iterator_tag;

            iterator() : ptr(nullptr), size(0), index(0) { };

            explicit iterator(tag_list_t *ptr_in, int size_in, int index_in = 0) : ptr(ptr_in), size(size_in), index(index_in) { };

            //const tag_prim_t<tag_type> *operator->() const { tag_prim_t<tag_type> ret; std::memcpy(&ret, &(ptr[index]->value)); };
            tag_iter_t<tag_type> &operator*() const requires is_nbt_primitive<tag_type> { return operator[](index); };
            tag_iter_t<tag_type> &operator[](int idx) const requires is_nbt_primitive<tag_type>
            {
                assert (ptr != nullptr);
                return std::get<mem::pmr::unique_ptr<tag_cont_t<tag_type>>>(ptr->operator[](idx))->template get<tag_type>();
            }

            // Hopefully force return elision of the string_view or span generated by the primitive get() for array types
            tag_iter_t<tag_type> operator*() const requires is_nbt_array<tag_type> || is_nbt_container<tag_type> { return operator[](index); };
            tag_iter_t<tag_type> operator[](int idx) const requires is_nbt_array<tag_type> || is_nbt_container<tag_type>
            {
                assert (ptr != nullptr);
                auto &cont_ref = std::get<mem::pmr::unique_ptr<tag_cont_t<tag_type>>>(ptr->operator[](idx));

                if constexpr (tag_properties[tag_type].category & (cat_compound | cat_list))
                    return cont_ref.get();
                else
                    return cont_ref->template get<tag_type>();
            }

            auto &operator++() { index++; return *this; };
            auto operator++(int) { auto old = *this; ++(*this); return old; };
            auto &operator--() { index--; return *this; };
            auto operator--(int) { auto old = *this; --(*this); return old; };
            auto &operator+=(int diff) { index += diff; return *this; };
            auto &operator-=(int diff) { index -= diff; return *this; };

            friend std::strong_ordering operator<=>(const iterator<tag_type> &lhs, const iterator<tag_type> &rhs) { return lhs.index <=> rhs.index; }
            friend bool operator==(const iterator<tag_type> &lhs, const iterator<tag_type> &rhs) { return (lhs.ptr == rhs.ptr) && (lhs.index == rhs.index); }

            friend int operator-(iterator<tag_type> lhs, iterator<tag_type> rhs) { return rhs.index - lhs.index; };
            friend iterator<tag_type> operator+(iterator<tag_type> itr, int diff) { return iterator<tag_type>(itr.ptr, itr.size, itr.index + diff); };
            friend iterator<tag_type> operator-(iterator<tag_type> itr, int diff) { return iterator<tag_type>(itr.ptr, itr.size, itr.index - diff); };
            friend iterator<tag_type> operator+(int diff, iterator<tag_type> itr) { return itr + diff; };
        };
        //@formatter:on

    private:

        std::variant<compound *, list *> parent;
        compound                         *top;
        std::pmr::memory_resource        *pmr_rsrc = std::pmr::get_default_resource();

    public:
        mem::pmr::unique_ptr<std::pmr::string> name;
        const tag_type_enum                    type  = tag_end;
        int32_t                                count = 0;

        list() = delete;

        list(const list &) = delete;
        list &operator=(const list &) = delete;

        list(list &&) = delete;
        list &operator=(list &&) = delete;

        void to_snbt(std::string &out);

        // @formatter:off
        template<tag_type_enum tag_type> requires (tag_type != tag_end)
        iterator<tag_type> begin()
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempt to create iterator of invalid NBT list type.");
            return iterator<tag_type>(&tags, tags.size());
        }

        template<tag_type_enum tag_type> requires (tag_type != tag_end)
        iterator<tag_type> end()
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempt to create iterator of invalid NBT list type.");
            return iterator<tag_type>(&tags, tags.size(), tags.size());
        }

        template<tag_type_enum tag_type>
        requires is_nbt_container<tag_type>
        auto &at(int idx)
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempted access of invalid NBT list type element.");
            auto cont_ptr = std::get<mem::pmr::unique_ptr<tag_cont_t<tag_type>>>(tags.at(idx)).get();
            return *cont_ptr;
        }

        template<tag_type_enum tag_type>
        requires is_nbt_primitive<tag_type>
        auto &at(int idx)
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempted access of invalid NBT list type element.");
            return std::get<mem::pmr::unique_ptr<tag_cont_t<tag_type>>>(tags.at(idx))->template get<tag_type>();
        }

        template<tag_type_enum tag_type>
        requires is_nbt_array<tag_type>
        auto at(int idx)
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempted access of invalid NBT list type element.");
            return std::get<mem::pmr::unique_ptr<tag_cont_t<tag_type>>>(tags.at(idx))->template get<tag_type>();
        }
        // @formatter:on

        // It's in compound.cpp :sob:
        template<tag_type_enum tag_type>
        requires (tag_type == tag_compound)
        std::optional<std::reference_wrapper<compound>> push(const std::function<void(compound &)> &builder = nullptr);

        template<tag_type_enum tag_type>
        requires (tag_type == tag_list)
        std::optional<std::reference_wrapper<list>> push(tag_type_enum tag_type_in, const std::function<void(list &)> &builder = nullptr)
        {
            auto container = mem::pmr::make_unique<list>(pmr_rsrc, this, "", tag_type_in);

            if (builder) builder(*container);

            auto cont_ptr = container.get();
            tags.push_back(std::move(container));

            count++;
            return *cont_ptr;
        }

        template<tag_type_enum tag_type, class V = tag_prim_t<tag_type>>
        requires is_nbt_primitive<tag_type> && is_nbt_type_match<V, tag_type>
        void push(V value)
        {
            auto tag_ptr = mem::pmr::make_unique<primitive_tag>(pmr_rsrc, type);

            if constexpr (tag_type == tag_byte)
                tag_ptr->value.tag_byte = value;
            else if constexpr (tag_type == tag_short)
                tag_ptr->value.tag_short = value;
            else if constexpr (tag_type == tag_int)
                tag_ptr->value.tag_int = value;
            else if constexpr (tag_type == tag_long)
                tag_ptr->value.tag_long = value;
            else if constexpr (tag_type == tag_float)
                tag_ptr->value.tag_float = value;
            else if constexpr (tag_type == tag_double)
                tag_ptr->value.tag_double = value;

            tags.push_back(std::move(tag_ptr));
            count++;
        }

        template<tag_type_enum tag_type>
        requires (tag_type == tag_string)
        void push(const std::string_view &str_in)
        {
            if (tag_type != this->type) throw std::runtime_error("Attempt to push value of wrong type to NBT list.");
            push_array_general<char>(str_in);
            count++;
        }

        template<tag_type_enum tag_type, class V = std::remove_pointer_t<tag_prim_t<tag_type>>, std::size_t N>
        requires is_nbt_array<tag_type> && is_nbt_type_match<std::add_pointer_t<V>, tag_type>
        void push(const std::array<V, N> &values)
        {
            if (tag_type != this->type) throw std::runtime_error("Attempt to push value of wrong type to NBT list.");
            push_array_general<V>(values);
            count++;
        }

        template<tag_type_enum tag_type, template<class, class...> class C = std::initializer_list, class V = std::remove_pointer_t<tag_prim_t<tag_type>>, class... N>
        requires is_nbt_array<tag_type> && is_nbt_type_match<std::add_pointer_t<V>, tag_type> && util::is_simple_iterable<C<V, N...>, V>
        void push(const C<V, N...> &values)
        {
            if (tag_type != this->type) throw std::runtime_error("Attempt to push value of wrong type to NBT list.");
            push_array_general<V>(values);
            count++;
        }

        void reserve(size_t count_in)
        { tags.reserve(count_in); }

        [[nodiscard]] auto size() const { return size_v; }

        template<tag_type_enum tag_type>
        struct range
        {
            list &list_ptr;

            auto begin()
            { return list_ptr.begin<tag_type>(); }

            auto end()
            { return list_ptr.end<tag_type>(); }
        };

        ~list();
    private:
        friend class compound;

        template<class T, class... Args>
        friend auto mem::pmr::make_obj_using_pmr(std::pmr::memory_resource *pmr_rsrc, Args &&... args)
        requires (!std::is_array_v<T>);

        explicit list(std::variant<compound *, list *> parent_in, std::string_view name_in, tag_type_enum tag_type_in);
        explicit list(char **itr_in, const char *itr_end, std::variant<compound *, list *>, mem::pmr::unique_ptr<std::pmr::string> name_in, tag_type_enum tag_type_in);

        char *read(char *itr, const char *itr_end);
        void adjust_size(int64_t by);
        void clean_primitives() noexcept;

        template<typename V>
        void push_array_general(const auto &values)
        {
            auto array_ptr = mem::pmr::make_unique<V[]>(pmr_rsrc, values.size() + (padding_size / sizeof(V)));
            auto tag_ptr = mem::pmr::make_unique<primitive_tag>(pmr_rsrc, type);

            tag_ptr->change_count(values.size());
            for (std::size_t idx = 0; const auto &value: values)
                array_ptr[idx++] = value;

            tag_ptr->value.generic_ptr = static_cast<void *>(array_ptr.get());
            tags.push_back(std::move(tag_ptr));
            static_cast<void>(array_ptr.release());
        }

        tag_list_t tags;

        uint16_t depth    = 0;
        size_t   size_v   = 0;
        int64_t  max_size = -1;
    };

    static_assert(std::random_access_iterator<list::iterator<tag_compound>>);
    static_assert(std::random_access_iterator<list::iterator<tag_list>>);
    static_assert(std::random_access_iterator<list::iterator<tag_int>>);
    static_assert(std::random_access_iterator<list::iterator<tag_string>>);
    static_assert(std::random_access_iterator<list::iterator<tag_int_array>>);
}

#endif //MELON_NBT_LIST_H
