//
// Created by MrGrim on 8/19/2022.
//

#ifndef MELON_NBT_LIST_H
#define MELON_NBT_LIST_H

#include <cstdint>
#include <iterator>
#include <string>
#include <vector>
#include <memory>
#include <memory_resource>
#include <cassert>
#include "nbt.h"

namespace melon::nbt
{
    class compound;

    class list
    {
    public:
        // @formatter:off
        template<tag_type_enum tag_type>
        requires is_nbt_primitive<tag_type> || is_nbt_array<tag_type>
        class iterator
        {
            primitive_tag *const * ptr;
            int     size;
            int     index;
        public:
            using value_type = tag_prim_t<tag_type>;
            using difference_type = int;
            using iterator_category = std::contiguous_iterator_tag;

            iterator() : ptr(nullptr), size(0), index(0) { };

            explicit iterator(void *ptr_in, int size_in, int index_in = 0) : ptr(static_cast<primitive_tag *const *>(ptr_in)), size(size_in), index(index_in) { };

            //const tag_prim_t<tag_type> *operator->() const { tag_prim_t<tag_type> ret; std::memcpy(&ret, &(ptr[index]->value)); };
            auto &operator*() const requires is_nbt_primitive<tag_type> { return operator[](index); };
            auto &operator[](int idx) const requires is_nbt_primitive<tag_type> { return ptr[idx]->get<tag_type>(); };

            // Hopefully force return elision of the string_view or span generated by the primitive get() for array types
            auto operator*() const requires is_nbt_array<tag_type> { return operator[](index); };
            auto operator[](int idx) const requires is_nbt_array<tag_type> { return ptr[idx]->get<tag_type>(); };

            auto &operator++() { index++; return *this; };
            auto operator++(int) { auto old = *this; ++(*this); return old; };
            auto &operator--() { index--; return *this; };
            auto operator--(int) { auto old = *this; --(*this); return old; };
            auto &operator+=(int diff) { index += diff; return *this; };
            auto &operator-=(int diff) { index -= diff; return *this; };

            friend std::strong_ordering operator<=>(const iterator<tag_type> &lhs, const iterator<tag_type> &rhs) { return lhs.index <=> rhs.index; }
            friend bool operator==(const iterator<tag_type> &lhs, const iterator<tag_type> &rhs) { return (lhs.ptr == rhs.ptr) && (lhs.index == rhs.index); }

            friend int operator-(iterator<tag_type> lhs, iterator<tag_type> rhs) { return rhs.index - lhs.index; };
            friend iterator<tag_type> operator+(iterator<tag_type> itr, int diff) { return iterator<tag_type>(itr.ptr, itr.size, itr.index + diff); };
            friend iterator<tag_type> operator-(iterator<tag_type> itr, int diff) { return iterator<tag_type>(itr.ptr, itr.size, itr.index - diff); };
            friend iterator<tag_type> operator+(int diff, iterator<tag_type> itr) { return itr + diff; };
        };
        //@formatter:on

        std::pmr::string    *name = nullptr;
        const tag_type_enum type  = tag_end;
        int32_t             count = 0;

        list() = delete;

        list(const list &) = delete;
        list &operator=(const list &) = delete;

        list(list &&) = delete;
        list &operator=(list &&) = delete;

        void to_snbt(std::string &out);

        // @formatter:off
        template<tag_type_enum tag_type> requires (tag_type != tag_end)
        iterator<tag_type> begin()
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempt to create iterator of invalid NBT list type.");
            return iterator<tag_type>(tags->data(), tags->size());
        }

        template<tag_type_enum tag_type> requires (tag_type != tag_end)
        iterator<tag_type> end()
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempt to create iterator of invalid NBT list type.");
            return iterator<tag_type>(tags->data(), tags->size(), tags->size());
        }

        template<tag_type_enum tag_type>
        requires is_nbt_primitive<tag_type>
        auto &at(int idx)
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempted access of invalid NBT list type element.");
            return (static_cast<tag_cont_t<tag_type> *>(tags->at(idx)))->template get<tag_type>();
        }

        template<tag_type_enum tag_type>
        requires is_nbt_array<tag_type> || is_nbt_container<tag_type>
        auto at(int idx)
        {
            if (type != tag_type) [[unlikely]] throw std::runtime_error("Attempted access of invalid NBT list type element.");

            if constexpr (tag_properties[tag_type].category & (cat_compound | cat_list))
                return static_cast<tag_cont_t<tag_type> *>(tags->at(idx));
            else
                return (static_cast<tag_cont_t<tag_type> *>(tags->at(idx)))->template get<tag_type>();
        }
        // @formatter:on

        template<tag_type_enum tag_type>
        struct range {
            list *list_ptr;
            auto begin() { return list_ptr->begin<tag_type>(); }
            auto end() { return list_ptr->end<tag_type>(); }
        };

        ~list() = default;
    private:
        friend class compound;

        explicit list(std::variant<compound *, list *> parent_in, std::string_view name_in, tag_type_enum tag_type_in);
        explicit list(char **itr_in, const char *itr_end, std::variant<compound *, list *>, std::pmr::string *name_in, tag_type_enum tag_type_in);

        std::pmr::vector<void *> *init_container();
        char *read(char *itr, const char *itr_end);

        std::variant<compound *, list *> parent;
        compound                         *top;
        std::pmr::memory_resource        *pmr_rsrc = std::pmr::get_default_resource();

        std::pmr::vector<void *> *tags;

        uint16_t depth    = 0;
        uint64_t size     = 0;
        int64_t  max_size = -1;

        //static_assert(std::contiguous_iterator<iterator<tag_compound>>);
        //static_assert(std::contiguous_iterator<iterator<tag_list>>);
        //static_assert(std::random_access_iterator<iterator<tag_int>>);
    };

    static_assert(std::random_access_iterator<list::iterator<tag_int>>);
    static_assert(std::random_access_iterator<list::iterator<tag_string>>);
}

#endif //MELON_NBT_LIST_H
